<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.Fight API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.Fight</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import List

from src.Animal import Animal
from src.Team import Team


class Fight:
    &#34;&#34;&#34;
    Fight Class

    Takes in two teams and simulates the battle
    &#34;&#34;&#34;

    def __init__(self, team1: Team, team2: Team):
        self.team1 = team1
        self.team2 = team2
        self.team1Friends = team1.getFriendCopy()
        self.team2Friends = team2.getFriendCopy()
        # Copy teams into new arrays
        # turn order is based on damage

    ### Actions ###

    def simulate(self) -&gt; None:
        &#34;&#34;&#34;
        onStartOfBattle in order of dmg
            onFaint if dies
            onAheadFaint if ahead dies
            onFriendSummoned if summoned
            onHurt if hurt

        while loop til no animals on one team
            onStartOfTurn
            onBeforeAttack for front animals
            attack - using getDmg and subHp
            onFaint
                if faint pop that animal out of arr
                if summons add animal in the dead one&#39;s place
                    call onSummoned for all others
            onHurt
            onFriendAheadFaint
            onFriendAheadAttack if not faint
        &#34;&#34;&#34;

        # I might need to make like a move buffer and just load into
        # that rather than recursively calling everything

        # Remove all of the NoneAnimals()
        self.team1Friends = self.__purgeNoneAnimals(self.team1Friends)
        self.team2Friends = self.__purgeNoneAnimals(self.team2Friends)

        # get start of fight move order for each team
        sob1 = self.__getMoveOrder(self.team1Friends)
        sob2 = self.__getMoveOrder(self.team2Friends)

        for i in range(5):
            # TODO refactor this shithole code
            try:
                self.team1Friends[sob1[i]].onStartOfBattle(
                    self.team1Friends, self.team2Friends
                )
            except:
                pass
            try:
                self.team2Friends[sob2[i]].onStartOfBattle(
                    self.team2Friends, self.team1Friends
                )
            except:
                pass

            self.__purgeDead()

        while len(self.team1Friends) &gt; 0 and len(self.team2Friends) &gt; 0:

            # trigger animal onBeforeAttack()
            self.team1Friends[0].onBeforeAttack(self.team1Friends, self.team2Friends)
            self.team2Friends[0].onBeforeAttack(self.team2Friends, self.team1Friends)

            # front animals attack
            self.team1Friends[0].attack(self.team1Friends, self.team2Friends)
            self.team2Friends[0].attack(self.team2Friends, self.team1Friends)

            # trigger behind animal onFriendAheadAttack()
            if len(self.team1Friends) &gt; 1:
                self.team1Friends[1].onFriendAheadAttack(
                    self.team1Friends, self.team2Friends
                )
            if len(self.team2Friends) &gt; 1:
                self.team2Friends[1].onFriendAheadAttack(
                    self.team2Friends, self.team1Friends
                )

            # purge dead
            self.__purgeDead()

            # Remove all of the NoneAnimals()
            self.team1Friends = self.__purgeNoneAnimals(self.team1Friends)
            self.team2Friends = self.__purgeNoneAnimals(self.team2Friends)
        #     print(&#34;team 1: &#34;, self.team1Friends)
        #     print(&#34;team 2: &#34;, self.team2Friends)

        # [print(i) for i in self.team1Friends]
        # [print(i) for i in self.team2Friends]

        if len(self.team1Friends) &gt; len(self.team2Friends):
            self.team2.loseLife()
        elif len(self.team2Friends) &gt; len(self.team1Friends):
            self.team1.loseLife()

        # print(self.team1)
        # print(self.team2)

    ### Private ###

    def __getMoveOrder(self, friends: List[Animal]) -&gt; list:
        team_sob = []

        for i in range(len(friends)):
            if len(team_sob) == 0:
                team_sob.append(i)
            else:
                for j in range(len(team_sob)):
                    if friends[team_sob[j]].getDmg() &lt; friends[i].getDmg():
                        team_sob.insert(j, i)
                        break
                    elif j == len(team_sob) - 1:
                        team_sob.append(i)
        return team_sob

    def __purgeDead(self):
        &#34;&#34;&#34;private method to purge dead animals&#34;&#34;&#34;
        for i in self.team1Friends:
            if not i.getAlive():
                ind = self.team1Friends.index(i)
                i.onFaint(self.team1Friends, self.team2Friends)
                if len(self.team1Friends) &gt; 1 + ind and self.team1Friends[ind + 1]:
                    self.team1Friends[ind + 1].onFriendAheadFaint(
                        self.team1Friends, self.team2Friends
                    )
                if i in self.team1Friends:
                    self.team1Friends.remove(i)
        for i in self.team2Friends:
            if not i.getAlive():
                ind = self.team2Friends.index(i)
                i.onFaint(self.team2Friends, self.team1Friends)
                if len(self.team2Friends) &gt; 1 + ind and self.team2Friends[ind + 1]:
                    self.team2Friends[ind + 1].onFriendAheadFaint(
                        self.team2Friends, self.team1Friends
                    )
                if i in self.team2Friends:
                    self.team2Friends.remove(i)

    def __purgeNoneAnimals(self, friends: List[Animal]) -&gt; List[Animal]:
        newTeam = []
        for i in friends:
            if i:
                newTeam.append(i)
        return newTeam</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.Fight.Fight"><code class="flex name class">
<span>class <span class="ident">Fight</span></span>
<span>(</span><span>team1: <a title="src.Team.Team" href="../Team/index.html#src.Team.Team">Team</a>, team2: <a title="src.Team.Team" href="../Team/index.html#src.Team.Team">Team</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Fight Class</p>
<p>Takes in two teams and simulates the battle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fight:
    &#34;&#34;&#34;
    Fight Class

    Takes in two teams and simulates the battle
    &#34;&#34;&#34;

    def __init__(self, team1: Team, team2: Team):
        self.team1 = team1
        self.team2 = team2
        self.team1Friends = team1.getFriendCopy()
        self.team2Friends = team2.getFriendCopy()
        # Copy teams into new arrays
        # turn order is based on damage

    ### Actions ###

    def simulate(self) -&gt; None:
        &#34;&#34;&#34;
        onStartOfBattle in order of dmg
            onFaint if dies
            onAheadFaint if ahead dies
            onFriendSummoned if summoned
            onHurt if hurt

        while loop til no animals on one team
            onStartOfTurn
            onBeforeAttack for front animals
            attack - using getDmg and subHp
            onFaint
                if faint pop that animal out of arr
                if summons add animal in the dead one&#39;s place
                    call onSummoned for all others
            onHurt
            onFriendAheadFaint
            onFriendAheadAttack if not faint
        &#34;&#34;&#34;

        # I might need to make like a move buffer and just load into
        # that rather than recursively calling everything

        # Remove all of the NoneAnimals()
        self.team1Friends = self.__purgeNoneAnimals(self.team1Friends)
        self.team2Friends = self.__purgeNoneAnimals(self.team2Friends)

        # get start of fight move order for each team
        sob1 = self.__getMoveOrder(self.team1Friends)
        sob2 = self.__getMoveOrder(self.team2Friends)

        for i in range(5):
            # TODO refactor this shithole code
            try:
                self.team1Friends[sob1[i]].onStartOfBattle(
                    self.team1Friends, self.team2Friends
                )
            except:
                pass
            try:
                self.team2Friends[sob2[i]].onStartOfBattle(
                    self.team2Friends, self.team1Friends
                )
            except:
                pass

            self.__purgeDead()

        while len(self.team1Friends) &gt; 0 and len(self.team2Friends) &gt; 0:

            # trigger animal onBeforeAttack()
            self.team1Friends[0].onBeforeAttack(self.team1Friends, self.team2Friends)
            self.team2Friends[0].onBeforeAttack(self.team2Friends, self.team1Friends)

            # front animals attack
            self.team1Friends[0].attack(self.team1Friends, self.team2Friends)
            self.team2Friends[0].attack(self.team2Friends, self.team1Friends)

            # trigger behind animal onFriendAheadAttack()
            if len(self.team1Friends) &gt; 1:
                self.team1Friends[1].onFriendAheadAttack(
                    self.team1Friends, self.team2Friends
                )
            if len(self.team2Friends) &gt; 1:
                self.team2Friends[1].onFriendAheadAttack(
                    self.team2Friends, self.team1Friends
                )

            # purge dead
            self.__purgeDead()

            # Remove all of the NoneAnimals()
            self.team1Friends = self.__purgeNoneAnimals(self.team1Friends)
            self.team2Friends = self.__purgeNoneAnimals(self.team2Friends)
        #     print(&#34;team 1: &#34;, self.team1Friends)
        #     print(&#34;team 2: &#34;, self.team2Friends)

        # [print(i) for i in self.team1Friends]
        # [print(i) for i in self.team2Friends]

        if len(self.team1Friends) &gt; len(self.team2Friends):
            self.team2.loseLife()
        elif len(self.team2Friends) &gt; len(self.team1Friends):
            self.team1.loseLife()

        # print(self.team1)
        # print(self.team2)

    ### Private ###

    def __getMoveOrder(self, friends: List[Animal]) -&gt; list:
        team_sob = []

        for i in range(len(friends)):
            if len(team_sob) == 0:
                team_sob.append(i)
            else:
                for j in range(len(team_sob)):
                    if friends[team_sob[j]].getDmg() &lt; friends[i].getDmg():
                        team_sob.insert(j, i)
                        break
                    elif j == len(team_sob) - 1:
                        team_sob.append(i)
        return team_sob

    def __purgeDead(self):
        &#34;&#34;&#34;private method to purge dead animals&#34;&#34;&#34;
        for i in self.team1Friends:
            if not i.getAlive():
                ind = self.team1Friends.index(i)
                i.onFaint(self.team1Friends, self.team2Friends)
                if len(self.team1Friends) &gt; 1 + ind and self.team1Friends[ind + 1]:
                    self.team1Friends[ind + 1].onFriendAheadFaint(
                        self.team1Friends, self.team2Friends
                    )
                if i in self.team1Friends:
                    self.team1Friends.remove(i)
        for i in self.team2Friends:
            if not i.getAlive():
                ind = self.team2Friends.index(i)
                i.onFaint(self.team2Friends, self.team1Friends)
                if len(self.team2Friends) &gt; 1 + ind and self.team2Friends[ind + 1]:
                    self.team2Friends[ind + 1].onFriendAheadFaint(
                        self.team2Friends, self.team1Friends
                    )
                if i in self.team2Friends:
                    self.team2Friends.remove(i)

    def __purgeNoneAnimals(self, friends: List[Animal]) -&gt; List[Animal]:
        newTeam = []
        for i in friends:
            if i:
                newTeam.append(i)
        return newTeam</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.Fight.Fight.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>onStartOfBattle in order of dmg
onFaint if dies
onAheadFaint if ahead dies
onFriendSummoned if summoned
onHurt if hurt</p>
<p>while loop til no animals on one team
onStartOfTurn
onBeforeAttack for front animals
attack - using getDmg and subHp
onFaint
if faint pop that animal out of arr
if summons add animal in the dead one's place
call onSummoned for all others
onHurt
onFriendAheadFaint
onFriendAheadAttack if not faint</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self) -&gt; None:
    &#34;&#34;&#34;
    onStartOfBattle in order of dmg
        onFaint if dies
        onAheadFaint if ahead dies
        onFriendSummoned if summoned
        onHurt if hurt

    while loop til no animals on one team
        onStartOfTurn
        onBeforeAttack for front animals
        attack - using getDmg and subHp
        onFaint
            if faint pop that animal out of arr
            if summons add animal in the dead one&#39;s place
                call onSummoned for all others
        onHurt
        onFriendAheadFaint
        onFriendAheadAttack if not faint
    &#34;&#34;&#34;

    # I might need to make like a move buffer and just load into
    # that rather than recursively calling everything

    # Remove all of the NoneAnimals()
    self.team1Friends = self.__purgeNoneAnimals(self.team1Friends)
    self.team2Friends = self.__purgeNoneAnimals(self.team2Friends)

    # get start of fight move order for each team
    sob1 = self.__getMoveOrder(self.team1Friends)
    sob2 = self.__getMoveOrder(self.team2Friends)

    for i in range(5):
        # TODO refactor this shithole code
        try:
            self.team1Friends[sob1[i]].onStartOfBattle(
                self.team1Friends, self.team2Friends
            )
        except:
            pass
        try:
            self.team2Friends[sob2[i]].onStartOfBattle(
                self.team2Friends, self.team1Friends
            )
        except:
            pass

        self.__purgeDead()

    while len(self.team1Friends) &gt; 0 and len(self.team2Friends) &gt; 0:

        # trigger animal onBeforeAttack()
        self.team1Friends[0].onBeforeAttack(self.team1Friends, self.team2Friends)
        self.team2Friends[0].onBeforeAttack(self.team2Friends, self.team1Friends)

        # front animals attack
        self.team1Friends[0].attack(self.team1Friends, self.team2Friends)
        self.team2Friends[0].attack(self.team2Friends, self.team1Friends)

        # trigger behind animal onFriendAheadAttack()
        if len(self.team1Friends) &gt; 1:
            self.team1Friends[1].onFriendAheadAttack(
                self.team1Friends, self.team2Friends
            )
        if len(self.team2Friends) &gt; 1:
            self.team2Friends[1].onFriendAheadAttack(
                self.team2Friends, self.team1Friends
            )

        # purge dead
        self.__purgeDead()

        # Remove all of the NoneAnimals()
        self.team1Friends = self.__purgeNoneAnimals(self.team1Friends)
        self.team2Friends = self.__purgeNoneAnimals(self.team2Friends)
    #     print(&#34;team 1: &#34;, self.team1Friends)
    #     print(&#34;team 2: &#34;, self.team2Friends)

    # [print(i) for i in self.team1Friends]
    # [print(i) for i in self.team2Friends]

    if len(self.team1Friends) &gt; len(self.team2Friends):
        self.team2.loseLife()
    elif len(self.team2Friends) &gt; len(self.team1Friends):
        self.team1.loseLife()

    # print(self.team1)
    # print(self.team2)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="../index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.Fight.Fight" href="#src.Fight.Fight">Fight</a></code></h4>
<ul class="">
<li><code><a title="src.Fight.Fight.simulate" href="#src.Fight.Fight.simulate">simulate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>